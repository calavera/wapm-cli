pub mod lockfile;
pub mod lockfile_command;
pub mod lockfile_module;

pub static LOCKFILE_NAME: &str = "wapm.lock";

static LOCKFILE_HEADER: &str = r#"# Lockfile v1
# This file is automatically generated by Wapm.
# It is not intended for manual editing. The schema of this file may change."#;

pub use crate::lock::lockfile::Lockfile;
pub use crate::lock::lockfile_command::LockfileCommand;
pub use crate::lock::lockfile_module::LockfileModule;
use crate::manifest::{MANIFEST_FILE_NAME};
use std::path::Path;
use crate::bonjour;

#[inline]
pub fn get_package_namespace_and_name(package_name: &str) -> Result<(&str, &str), failure::Error> {
    let split: Vec<&str> = package_name.split('/').collect();
    match &split[..] {
        [namespace, name] => Ok((*namespace, *name)),
        [global_package_name] => Ok(("_", *global_package_name)),
        _ => bail!("Package name is invalid"),
    }
}

pub fn is_lockfile_out_of_date<P: AsRef<Path>>(directory: P) -> Result<bool, failure::Error> {
    use std::fs;
    let wapm_lock_metadata = fs::metadata(directory.as_ref().join(LOCKFILE_NAME))?;
    let wapm_toml_metadata = fs::metadata(directory.as_ref().join(MANIFEST_FILE_NAME))?;
    let wapm_lock_last_modified = wapm_lock_metadata.modified()?;
    let wapm_toml_last_modified = wapm_toml_metadata.modified()?;
    Ok(wapm_lock_last_modified < wapm_toml_last_modified)
}

pub fn regenerate_lockfile(
    installed_dependencies: Vec<(&str, &str)>,
) -> Result<(), failure::Error> {
    bonjour::update(installed_dependencies).unwrap();
    Ok(())
}
